#!/usr/bin/env python3
import requests
import subprocess as s
from typing import Optional, Tuple
import os
import sys

# --- Configuraci√≥n ---
def load_config():
    config = {
        'HOST': 'localhost',
        'PORT': 9090,
        'WOFI_CFG': os.path.expanduser("~/.config/wofi/dracula/style.css"),
        'LOCK_TIMEOUT': 10
    }
    
    config_path = os.path.expanduser("~/.config/bwmenu.conf")
    if os.path.exists(config_path):
        with open(config_path, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#'):
                    key, value = line.split('=', 1)
                    config[key.strip()] = value.strip()
    else:
        with open(config_path, 'w') as f:
            f.write("HOST=localhost\n")
            f.write("PORT=9090\n")
            f.write("WOFI_CFG=~/.config/wofi/dracula/style.css\n")
            f.write("LOCK_TIMEOUT=10\n")
    
    # Expandir tilde en WOFI_CFG si existe
    config['WOFI_CFG'] = os.path.expanduser(config['WOFI_CFG'])
    return config

CONFIG = load_config()
WOFI = ["wofi", "-W", "450", "--show", "dmenu", "-s", CONFIG['WOFI_CFG']]

class Bw():
    def __init__(self, host: str, port: int, timeout: int = 5):
        self.host = host
        self.port = port
        self.timeout = timeout
        self._data = None
        self.session = requests.Session()

    def _request(self, method, endpoint, **kwargs):
        """M√©todo centralizado para requests HTTP con manejo de errores"""
        url = f'http://{self.host}:{self.port}/{endpoint.lstrip("/")}'
        kwargs.setdefault('timeout', self.timeout)
        try:
            response = self.session.request(method, url, **kwargs)
            response.raise_for_status()
            return response
        except requests.RequestException as e:
            self.notificacion(f"<b>‚ùå Error de red</b>\n{str(e)}")
            return None

    def sync(self):
        """Refresca datos del servidor"""
        return self._request('POST', '/sync')

    def lock(self):
        """Bloquea el vault"""
        return self._request('POST', '/lock')

    def unlock(self):
        """Desbloquea el vault"""
        contra = self.menuContra()
        if not contra: return None
        return self._request('POST', '/unlock', json={'password': contra})

    @property
    def data(self):
        """Property con lazy loading de datos"""
        if self._data is None:
            self.leeDatos()
        return self._data

    def leeDatos(self):
        """Carga los datos del vault"""
        response = self._request('GET', '/list/object/items')
        if response:
            self._data = response.json()
        else:
            self._data = {'data': {'data': []}}

    @property
    def getNombres(self) -> list:
        """Retorna lista de elementos en formato 'nombre: usuario'"""
        if self._data is None:
            self.leeDatos()
        
        res = []
        try:
            items = self.data.get('data', {}).get('data', [])
            for item in items:
                if 'login' in item:
                    name = item['name'].strip()
                    username = item['login'].get('username', '')
                    if username:
                        res.append(f"{name}: {username}")
        except (KeyError, AttributeError):
            pass
        return sorted(res)

    def getDatos(self, nombre: str, username: str) -> Optional[Tuple]:
        """Obtiene datos espec√≠ficos de un elemento"""
        items = self.data.get('data', {}).get('data', [])
        for item in items:
            if (item.get('name') == nombre and 
                'login' in item and 
                item['login'].get('username') == username):
                
                login_data = item['login']
                return (
                    login_data.get('password'),
                    login_data.get('username'),
                    item.get('id'),
                    login_data.get('totp')
                )
        return None

    def getTotp(self, nombre: str, username: str) -> Optional[str]:
        """Obtiene c√≥digo TOTP para un elemento"""
        datos = self.getDatos(nombre, username)
        if datos and datos[2]:
            item_id = datos[2]
            response = self._request('GET', f'/object/totp/{item_id}')
            if response and response.status_code == 200:
                return response.json().get('data', {}).get('data')
        return None

    @property
    def estado(self) -> Optional[str]:
        """Retorna: 'unlocked', 'locked' o None si hay error"""
        response = self._request('GET', '/status')
        if response:
            data = response.json()
            if data.get('success'):
                return data['data']['template']['status']
        return None

    def menuContra(self) -> Optional[str]:
        """Muestra men√∫ para ingresar contrase√±a"""
        menu = s.run(
            WOFI+["--password", "--prompt", "Contrase√±a:"],
            input='Introduce la contrase√±a para desbloquear',
            capture_output=True,
            text=True
        )
        if menu.returncode == 0:
            return menu.stdout.strip()
        return None

    def menuElementos(self) -> Optional[str]:
        """Muestra men√∫ para seleccionar elemento"""
        nombres = self.getNombres
        opciones = ["Û∞åæ  Bloquear cofre", "Û∞ëñ  Sincronizar datos"] + nombres
        menu = s.run(
            WOFI+["--prompt", "üîç Buscar elemento..."],
            input='\n'.join(opciones),
            capture_output=True,
            text=True
        )
        if menu.returncode == 0:
            return menu.stdout.strip()
        return None

    def menuCopiaDato(self, elemento: str) -> Optional[str]:
        """Muestra men√∫ para seleccionar qu√© dato copiar"""
        if elemento == "Û∞åæ  Bloquear cofre":
            self.lock()
            self.notificacion('<b>üîí Gestor bloqueado</b>')
            return None
        elif elemento == "Û∞ëñ  Sincronizar datos":
            self.sync()
            self.notificacion('<b>Û∞ëñ Datos sincronizados</b>')
            return self.menuElementos()

        if ':' not in elemento:
            return None

        sitio, username = elemento.split(':', 1)
        sitio = sitio.strip()
        username = username.strip()
        
        datos = self.getDatos(sitio, username)
        if not datos:
            return None
        
        elementos = [f'üë§ Username: {username}', 'üîí Contrase√±a: *******']
        if datos[3]:  # Si tiene TOTP
            elementos.append('‚è±Ô∏è TOTP: ******')
        
        menu = s.run(
            WOFI+["--prompt", "Selecciona dato a copiar:"],
            input='\n'.join(elementos),
            capture_output=True,
            text=True
        )
        if menu.returncode == 0:
            return menu.stdout.strip()
        return None

    def notificacion(self, texto: str):
        s.run(
            ["notify-send", "-a", "wofi-bitwarden-menu", "-t", "3000", "Bitwarden", texto]
        )

    def main(self):
        """Flujo principal de la aplicaci√≥n"""
        elemento = self.menuElementos()
        if not elemento: return
        
        # Si el usuario eligi√≥ bloquear o refrescar en el primer men√∫, ya se manej√≥ en menuCopiaDato indirectamente
        # o necesitamos volver a llamar si era refrescar datos.
        if elemento in ["Û∞åæ  Bloquear cofre", "Û∞ëñ  Sincronizar datos"]:
            dato = self.menuCopiaDato(elemento)
            if not dato: return
            elemento = dato # Si volvi√≥ de un refresco, el nuevo elemento est√° aqu√≠
        
        dato = self.menuCopiaDato(elemento)
        if not dato: return
        
        # Si despu√©s de elegir elemento eligi√≥ una acci√≥n de sistema:
        if dato in ["Û∞åæ  Bloquear cofre", "Û∞ëñ  Sincronizar datos"]:
            return

        sitio, username = elemento.split(':', 1)
        sitio = sitio.strip()
        username = username.strip()
        
        if dato.startswith('üë§ Username'):
            s.run(['wl-copy', username], check=False)
            self.notificacion('<b>üë§ Username copiado</b>')
        elif dato.startswith('üîí Contrase√±a'):
            res = self.getDatos(sitio, username)
            if res:
                password = res[0]
                s.run(['wl-copy'], input=password, text=True, timeout=5, check=False)
                self.notificacion('<b>üîí Contrase√±a copiada</b>')
        elif dato.startswith('‚è±Ô∏è TOTP'):
            totp = self.getTotp(sitio, username)
            if totp:
                s.run(['wl-copy', totp], check=False)
                self.notificacion('<b>‚è±Ô∏è TOTP copiado</b>')

if __name__ == '__main__':
    bw = Bw(CONFIG['HOST'], int(CONFIG['PORT']))
    
    estado = bw.estado
    if estado is None:
        sys.exit(1)
    
    if estado == 'locked':
        res = bw.unlock()
        if not res or not res.json().get('success'):
            sys.exit(1)
        bw._data = None
    
    # Reiniciar temporizador de bloqueo
    if s.run(["which", "wofi-bitwarden-mata"], stdout=s.DEVNULL).returncode == 0:
        s.run(["wofi-bitwarden-mata"], stderr=s.DEVNULL, text=True)
    
    if s.run(["which", "wofi-bitwarden-bloquea"], stdout=s.DEVNULL).returncode == 0:
        s.Popen(['wofi-bitwarden-bloquea', str(CONFIG['LOCK_TIMEOUT'])],
                stdout=s.DEVNULL, stderr=s.DEVNULL, text=True)

    bw.main()

