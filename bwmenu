#!/usr/bin/env python3
import requests
import subprocess as s
from typing import Optional, Tuple
import os

WOFI_CFG=os.path.expanduser("~/.config/wofi/dracula/style.css")
WOFI=["wofi", "-W", "450", "--show", "dmenu", "-s", WOFI_CFG]

class Bw():
    def __init__(self, host: str, port: int, timeout: int = 5):
        self.host = host
        self.port = port
        self.timeout = timeout
        self._data = None  # Cambiar a None para mejor cache
        self.session = requests.Session()

    def _request(self, method, endpoint, **kwargs):
        """M√©todo centralizado para requests HTTP"""
        url = f'http://{self.host}:{self.port}/{endpoint.lstrip("/")}'
        kwargs.setdefault('timeout', self.timeout)
        return self.session.request(method, url, **kwargs)

    def sync(self):
        """Refresca datos del servicir"""
        return self._request('POST', '/sync')

    def lock(self):
        """Bloquea el vault"""
        return self._request('POST', '/lock')

    def unlock(self):
        """Desbloquea el vault"""
        contra = self.menuContra()
        return self._request('POST', '/unlock', json={'password': contra})

    @property
    def data(self):
        """Property con lazy loading de datos"""
        if self._data is None:
            self.leeDatos()
        return self._data

    def leeDatos(self):
        """Carga los datos del vault"""
        response = self._request('GET', '/list/object/items')
        response.raise_for_status()
        self._data = response.json()

    @property
    def getNombres(self) -> list:
        """Retorna lista de elementos en formato 'nombre: usuario'"""
        if self._data is None:
            self.leeDatos()
        
        res = []
        for item in self.data['data']['data']:
            if 'login' in item:
                name = item['name']
                username = item['login'].get('username', '')
                if username:  # Solo si tiene username
                    res.append(f"{name}: {username}")
        return sorted(res)  # Ordenado y sin duplicados

    def getDatos(self, nombre: str, username: str) -> Optional[Tuple]:
        """Obtiene datos espec√≠ficos de un elemento"""
        for item in self.data['data']['data']:
            if (item.get('name') == nombre and 
                'login' in item and 
                item['login'].get('username') == username):
                
                login_data = item['login']
                return (
                    login_data.get('password'),
                    login_data.get('username'),
                    item.get('id'),
                    login_data.get('totp')
                )
        return None

    def getTotp(self, nombre: str, username: str) -> Optional[str]:
        """Obtiene c√≥digo TOTP para un elemento"""
        datos = self.getDatos(nombre, username)
        if datos and datos[2]:  # Si tiene ID
            item_id = datos[2]
            response = self._request('GET', f'/object/totp/{item_id}')
            if response.status_code == 200:
                return response.json()['data']['data']
        return None

    @property
    def estado(self) -> Optional[str]:
        """Retorna: 'unlocked', 'locked' o None si hay error"""
        try:
            response = self._request('GET', '/status')
            response.raise_for_status()
            data = response.json()
            if data.get('success'):
                return data['data']['template']['status']
        except requests.RequestException:
            print('Error de conexi√≥n con el host')
        return None

    def menuContra(self) -> Optional[str]:
        """Muestra men√∫ para ingresar contrase√±a"""
        menu = s.run(
            WOFI+["--password", "--prompt", "Contrase√±a:"],
            input='Introduce la contrase√±a para desbloquear',
            capture_output=True,
            text=True
        )
        if menu.returncode == 0:
            return menu.stdout.strip()
        return None

    def menuElementos(self) -> Optional[str]:
        """Muestra men√∫ para seleccionar elemento"""
        menu = s.run(
            WOFI+["--prompt", "üîç Selecciona elemento:"],
            input='\n'.join(["üîí Bloquear gestor contrase√±as",
                            "Û∞ëñ  Releer datos"] + self.getNombres),
            capture_output=True,
            text=True
        )
        if menu.returncode == 0:
            return menu.stdout.strip()
        return None

    def menuCopiaDato(self, elemento: str) -> Optional[str]:
        """Muestra men√∫ para seleccionar qu√© dato copiar"""
        if elemento[2:] == 'Bloquear gestor contrase√±as':
            self.lock()
            self.notificacion('<b>üîí Gestor bloqueado</b>')
            return None
        elif elemento == "Û∞ëñ  Releer datos":
            self.sync()
            self.notificacion('<b>Û∞ëñ Datos sicronizados</b>')
            elemento=self.menuElementos()

        sitio, username = elemento.split(':', 1)
        sitio = sitio.strip()
        username = username.strip()
        
        datos = self.getDatos(sitio, username)
        if not datos:
            return None
        
        elementos = [f'üë§ Username: {username}', 'üîí Contrase√±a: *******']
        if datos[3]:  # Si tiene TOTP
            elementos.append('‚è±Ô∏è TOTP: ******')
        
        menu = s.run(
            WOFI+["--prompt", "Selecciona dato a copiar:"],
            input='\n'.join(elementos),
            capture_output=True,
            text=True
        )
        if menu.returncode == 0:
            return menu.stdout.strip()
        return None

    def notificacion(self, texto: str):
        s.run(
            ["notify-send", "-a", "Bitwarden", "-t", "3000", "Bitwarden", texto]
        )


    def main(self):
        """Flujo principal de la aplicaci√≥n"""
        if not (elemento := self.menuElementos()):
            return
        
        if not (dato := self.menuCopiaDato(elemento)):
            return
        
        sitio, username = elemento.split(':', 1)
        sitio = sitio.strip()
        username = username.strip()
        
        if dato.startswith('üë§ Username'):
            s.run(['wl-copy', username], check=False)
            self.notificacion('<b>üë§  Username copiado</b>')
        elif dato.startswith('üîí Contrase√±a'):
            password, *_ = self.getDatos(sitio, username) or ('',)
            if password:
                s.run(['wl-copy'], input=password, text=True, timeout=5, check=False)
                self.notificacion('<b>üîí Contrase√±a copiada</b>')
        elif dato.startswith('‚è±Ô∏è TOTP'):
            totp = self.getTotp(sitio, username)
            if totp:
                s.run(['wl-copy', totp], check=False)
                self.notificacion('<b>‚è±Ô∏è  TOTP copiado</b>')

if __name__ == '__main__':
    bw = Bw('rpi5c', 9090)
    
    estado = bw.estado
    if estado is None:
        print("No se pudo conectar al servidor")
        exit(1)
    
    if estado == 'locked':
        res = bw.unlock()
        if not res.json().get('success'):
            print("Error al desbloquear")
            exit(1)
        # Despu√©s de desbloquear, hay que recargar datos
        bw._data = None
    
    s.run([os.path.expanduser('~/.local/bin/mata-bloqueo-bw.sh')],
            stderr=s.STDOUT,
            text=True
    )
    
    s.Popen(
        ['bash', os.path.expanduser('~/.local/bin/bloquea-bw.sh'), "10"],
        stdout=s.PIPE,  # Capturar salida
        stderr=s.PIPE,
        text=True
    )

    bw.main()
